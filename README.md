# DI-Container
![CMake](https://github.com/FeggieBoss/DI-Container/actions/workflows/cmake.yml/badge.svg)

# DI Containers
## Dependency injection 
**Внедрение зависимостей** — это стиль настройки объекта, при котором поля объекта задаются внешней сущностью. Другими словами, объекты настраиваются внешними объектами. DI — это альтернатива самонастройке объектов.  
Пример (взят с [_link_](https://habr.com/ru/post/350068/)):  
```
public class MyDao {
    private DataSource dataSource =
        new DataSourceImpl("driver", "url", "user", "password");

    //data access methods...
    public Person readPerson(int primaryKey) {...}
}
```
Класс MyDao создает экземпляр DataSourceImpl. Тот факт, что MyDao нуждается в реализации DataSource, означает, что он зависит от него. Следовательно, MyDao имеет «зависимость» от интерфейса DataSource и от какой-то его реализации.  
Класс MyDao создает экземпляр DataSourceImpl как реализацию DataSource. Следовательно, класс MyDao сам **_разрешает свои зависимости_**, что делает его негибким в отношении к этим зависимостям. Это приводит к тому, что если вам нужно поменять зависимости, вам нужно поменять код.  
```
public class MyDao {
    private final DataSource dataSource;
    
    public MyDao(DataSource dataSource){
      this.dataSource = dataSource;
    }

    //data access methods...
    public Person readPerson(int primaryKey) {...}
}
```
Теперь класс MyDao больше не зависит от класса DataSourceImpl или от четырех строк, необходимых конструктору DataSourceImpl. Теперь можно использовать любую реализацию DataSource в конструкторе MyDao.  Но вместо этого теперь придётся знать о реализации DataSourceImpl на более высоких уровнях абстракции, что ещё хуже:
```
MyDao dao = new MyDao(new DataSourceImpl("driver", "url", "user", "password"));
```
Решение — продолжить внедрение зависимости по всем слоям. Таким образом, Такой **паттерн внедрения зависимости должен продолжаться через все слои приложения, с самого нижнего слоя** (слоя доступа к данным) до пользовательского интерфейса (если он есть).

## Dependency inversion
**Инверсия зависимостей** - SOLID принцип, говорящий о том, что модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций; абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
```
public class Foo {
  private Bar itsBar;

  public Foo() {
     itsBar = new Bar();
  }
}
```
Проблема здесь заключается в том, что класс Foo зависит от конкретного класса Bar. По той или иной причине — в целях расширяемости, переиспользуемости или тестируемости ради — может встать задача их разделить. Согласно принципу инверсии зависимости для этого следует ввести между ними промежуточную абстракцию.
```
public class Foo {
  private IBar itsBar;

  public Foo() {
     itsBar = new Bar();
  }
}
```
Диаграмма UML наглядно демонстрирует оба варианта.  
![image](https://user-images.githubusercontent.com/71063054/161337383-46158995-e69c-4dce-825f-730ed4c1bef3.png)  
Где же здесь инверсия? Основополагающая идея, без понимания которой невозможно ответить на этот вопрос, заключается в том, что интерфейсы принадлежат не своим реализациям, а использующим их клиентам. Имя интерфейса IBar вводит в заблуждение и заставляет рассматривать связку IBar + Bar как единое целое. В то же время истинным владельцем IBar является класс Foo, и если принять это во внимание, то направление связи между Foo и Bar действительно обратится вспять.  
![image](https://user-images.githubusercontent.com/71063054/161337422-4cd49408-338f-496d-91e9-779722063fcf.png)


## DI Container description
(Марк Симан, Стивен Ван Дерсен _Внедрение зависимостей на платформе .NET_)
> Def. ``DI-контейнер – это библиотека, которая обеспечивает функциональность механизма внедрения зависимостей.``  
Def. 
`` DI-контейнер - это  программная библиотека, позволяющая автоматизировать многие задачи, связанные с компоновкой объектов, управлением временем их жизни и их перехватом.``  


DI-контейнер представляет собой программную библиотеку, похожую на любую
другую библиотеку программных модулей. Она предоставляет API, которым можно
воспользоваться для компоновки объектов и составления графа объектов в рамках
одного вызова метода. DI-контейнеры также требуют, чтобы до компоновки объектов было проведено их конфигурирование.

# DI-контейнер Autofac

Autofac — полноценный DI-контейнер, предлагающий тщательно спроектированный и надежный API. Он появился в конце 2007 года и на момент написания книги
был самым популярным контейнером.  

### Features
1. Составление графов объектов
2. Отображение абстракций на конкретные типы
3. Конфигурирование областей
видимости экземпляров
4. Высвобождение компонентов
5. Разрешение слабо типизированных сервисов

### Main remarks
- DI-контейнер Autofac предлагает полноценный API и справляется со множеством непростых ситуаций, которые часто возникают при использовании DI-контейнеров.
- Похоже, что для Autofac наиболее важна четкость выражения задуманного.
Он не пытается строить предположения о сути вашего замысла, а предлагает простой и понятный API, предоставляющий варианты явного включения функций.
- Autofac четко разграничивает конфигурирование и потребление контейнера. Конфигурирование компонентов выполняется с помощью экземпляра
ContainerBuilder, но сам ContainerBuilder не может выполнять разрешение
компонентов. Когда конфигурирование с помощью ContainerBuilder завершится,
оно применяется для создания IContainer, которым можно воспользоваться для
разрешения компонентов.
- При использовании Autofac выполнять разрешение непосредственно из корневого контейнера не принято. Это легко может привести к утечкам памяти или
ошибкам одновременных вычислений. Разрешение всегда нужно выполнять из
области видимости времени жизни.
- Autofac поддерживает стандартные жизненные циклы Transient, Singleton
и Scoped.
- Autofac дает возможность работать с неопределенными конструкторами и типами
за счет API, позволяющего предоставлять блоки кода. Благодаря этому можно
выполнять любой код, создающий сервис.
